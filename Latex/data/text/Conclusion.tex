Cette partie finale est composée d'une section «~conclusions~» ainsi que de propositions de recherches futures pour continuer ce mémoire. Finalement, une description de ce que ce mémoire m'a apporté est donnée. Les conclusions portent aussi bien sur les notions théoriques des algorithmes de localisation que sur les problèmes pratiques rencontrés au cours du mémoire. En effet, sans considérer la pratique, il est impossible d'avoir des algorithmes de localisation de qualité. 


\chapter{Conclusions}


\section{Implémentation}
Bien que les concepts globaux théoriques des algorithmes semblent à première vue simples, il s'avère qu'implémenter de tels algorithmes de localisation sur un robot réel demande de résoudre une quantité importante de sous-problèmes.  En effet, un algorithme de localisation n'est pas un élément isolé, il doit être incorporé dans un tout cohérent. Il est donc primordial d'avoir une compréhension d'ensemble ainsi qu'une compréhension détaillée de l'implémentation du robot. Il est également important de garder en tête l'objectif du robot et de déterminer l'environnement dans lequel le robot évolue pour déterminer les modèles et  les algorithmes qui correspondent le mieux à ses caractéristiques.  Il s'avère que la construction du robot a un impact sur les modèles. Le type de plateforme, la position des capteurs, la vitesse d'utilisation des moteurs sont autant d'éléments qui doivent être pris en considération lors de la construction du modèle de mouvement et de mesure. 
\section{Composants à faible coût}
Ce mémoire a démontré qu'il est possible de localiser un robot dans un environnement simple à l'aide de capteurs, de moteurs et de processeurs à faible cout. L'algorithme MCL démontre qu'il est possible d'utiliser des capteurs très peu couteux comme des capteurs infrarouges pour se localiser dans un environnement statique. Cependant, lorsque l'environnement possède des éléments non cartographiés, l'algorithme MCL est moins efficace. L'algorithme EKF nécessite des capteurs capables de collecter des données qui sont analysées pour localiser un point de repère. Ils sont donc plus couteux, mais restent abordables. Il s'avère également que l'extraction des points de repère des données brutes du capteur nécessite une quantité de traitements non négligeable. Extraire des points de repère d'une image haute définition nécessite un processeur ou une carte graphique puissante. Cependant, l'algorithme EKF compense ce besoin de puissance par la faible complexité de l'étape de mise à jour de la croyance de la pose du robot. Finalement, ces algorithmes sont utilisables sans modification pour des robots différents et des capteurs différents. Seuls les modèles de mouvement et de mesure sont à adapter. Le même algorithme de localisation peut donc être utilisé avec un simple capteur infrarouge ou même avec un Lidar 3D. Cependant, l'augmentation de la taille des vecteurs d'observation et du vecteur de  pose implique un surplus de consommation CPU.
\section{Recherche de chemin}
L'implémentation des algorithmes de recherche de chemin démontre qu'il est possible d'utiliser les algorithmes de localisation pour construire des cartes dynamiques qui sont ensuite utilisées par les algorithmes de recherche de chemin. Les cartes dynamiques sont générées à l'aide de capteurs simples comme le détecteur de pression et le capteur de distance. Une fois le graphe construit à l'aide des cartes disponibles, il est possible d'utiliser l'ensemble des algorithmes de recherche de chemin dans un graphe. Les algorithmes de Dijkstra et $A^*$ se sont révélés sans surprise très efficaces pour trouver des chemins dans ces graphes. 
 






\chapter{Recherches futures  }
Ce mémoire n'a fait qu'effleurer la localisation d'un robot mobile dans son environnement, ce qui n'est qu'un sous-domaine de l'intelligence artificielle dans la robotique. Il y a donc un grand nombre de possibilités pour continuer ce mémoire. Les sections suivantes présentent les pistes qui me semblent les plus intéressantes. 

\section{Analyse d'images}
\label{sec:Analyse d'images}
Dans ce mémoire, le choix d'utiliser des codes QR a permis de simplifier la détection de repères pour l'algorithme EKF. Cependant, il n'est pas possible d'utiliser des codes QR dans toutes les situations. Il est donc important de savoir extraire des repères des données brutes des capteurs. De nombreux algorithmes permettent d'extraire des repères à l'aide d'une caméra. Ce domaine de recherche discute des différents éléments qui sont considérés comme de bons repères. Par exemple, la détection de bord se base sur de fortes modifications de la lumière dans une image. L'ensemble des points où cette forte modification de lumière apparait est considéré comme un bord. L'algorithme de Canny est un exemple d'algorithme de détection de bords~\cite{Canny86acomputational}. De la même manière, les algorithmes de détection de coins tentent de déterminer les caractéristiques d'un coin. L'algorithme de Moravec~\cite{Moravec_1980_22} et de Harris et Stephens~\cite{Harris88acombined} sont des exemples d'algorithmes de détection de coins.  



 


\section{Ajout d'IA dans Lejos}


Dans un but pédagogique, il serait intéressant de continuer à développer la librairie Lejos. Rappelons qu'elle est utilisée par de nombreuses écoles et universités. Elle fournit déjà un nombre important de classes pour manipuler un robot. Cet outil est donc parfait pour développer en pratique des aspects théoriques. Cependant, elle souffre du peu de classes permettant de développer une intelligence artificielle. Il serait donc intéressant d'implémenter des algorithmes de localisation utilisant d'autres types de capteurs, ou bien des algorithmes de prise de décision pour atteindre un objectif. Ces algorithmes pourraient être assemblés pour construire un tout cohérent. De plus, cette librairie est écrite en Java et avec un bon niveau de décomposition des éléments. Elle est donc facilement réutilisable dans d'autres projets. Elle pourrait ainsi devenir un outil semblable à ROS \footnote{ROS : \href{http://www.ros.org/}{www.ros.org} } ou MSRDS\footnote{Microsoft Robotics Developer Studio 4 : \href{https://www.microsoft.com/en-us/download/details.aspx?id=29081}{www.microsoft.com}} qui sont des outils professionnels de haute qualité fonctionnant aussi bien sur des robots industriels que des robots de loisirs comme les drones.

\section{Prise de décisions}
Les algorithmes présentés dans ce mémoire sont des algorithmes qui ne prennent aucune décision. Le parcours donné au robot pour lui permettre de se localiser rapidement est soit donné étape par étape par le développeur ou par des étapes générées aléatoirement. Il est cependant intéressant que le robot puisse prendre lui-même la décision d'effectuer un certain parcours. Par exemple, un véhicule sous-marin qui doit relier un port canadien jusqu'à un port de la mer Caspienne doit-il prendre le chemin le plus court sous la glace et risquer de perdre le signal GPS ou prendre le chemin le plus long~? Il n'est plus question de simplement trouver un chemin possible comme présenté dans le chapitre~\ref{chap:Algorithmesderecherchechemin}, mais plutôt de trouver le meilleur chemin. Ce type de problème peut être résolu en pondérant les arêtes d'un graphe selon les risques d'emprunter un chemin donné. Cependant, ces couts doivent être liés à une probabilité et non à un cout fixe. Dans notre exemple, ce cout est fonction de la probabilité de perdre le signal GPS. Ce type de problème peut être résolu à l'aide d'un modèle de processus de décision markovien qui est décrit dans le livre Probabilistic Robotics~\cite{Thrun:2005:PR:1121596}. Ces algorithmes probabilistes de prise de décisions sont donc dans la continuité de ceux présentés dans ce mémoire. Ils sont donc de bonnes pistes de recherche futures.



\chapter{Enrichissements personnels}
Ce chapitre est destiné à expliquer ce que la réalisation de ce mémoire m'a apporté. Elle m'a apporté de nouvelles connaissances, m'a permis d'en approfondir d'autres, et m'a également appris sur moi-même. La première et la deuxième partie ce chapitre se concentrent plus sur les compétences et  les connaissances qui ont été améliorées. Tandis que la dernière partie est plus centrée sur mes capacités de gestion de projet et mes connaissances sur moi-même. En effet, il est important de définir des objectifs réalistes en connaissant ses points forts, ses points faibles et sa tolérance à la charge de travail. 

\section{Projets open source} 
La librairie Lejos ainsi que la librairie Commons Math sont deux librairies open source de taille moyenne. Bien que l'apprentissage de ces librairies m'a pris un temps certain, le fait de pouvoir réutiliser des briques déjà implémentées permet d'obtenir un travail de qualité supérieure en comparaison à un projet commencé à partir de zéro. Je pense qu'utiliser des librairies open source est la meilleure façon d'apprendre et de progresser en informatique. Le code source de ce genre de librairie est de taille importante et il est réalisé par des personnes différentes. Ceci permet lors de l'analyse de ce code source d'apprendre de chacun des programmeurs ayant ajouté leur brique à l'édifice. En effet, chacun a son style de programmation. Il est donc possible de retirer le meilleur de chacun des styles de programmation présents dans la librairie. De plus, cette technique permet d'apprendre à coder en équipe. Bien que chaque partie de code ne correspond pas toujours à nos attentes, il est primordial de l'adapter aux fonctionnalités qu'on souhaite ajouter. Ceci sans pour autant modifier le comportement déjà implémenté. De plus, les fonctionnalités et le code créés par vos soins vont être commentés et ajustés. Ceci permet d'avoir un bon feedback sur nos erreurs de programmation. Finalement, la popularité des projets open source n'est plus à démontrer. Linux, Firefox, Eclipse, sont autant de projets de qualité et ils sont indispensables dans leur domaine.


\section{Domaine complet}
Par sa nature complète et complexe, la robotique aborde un grand nombre de sujets et de sous-sujets, aussi bien liés à l'informatique, qu'aux mathématiques en passant par la physique et la mécanique. Ce mémoire m'a donc permis de revoir des algorithmes importants,  de l'analyse de graphes, des formules physiques, des concepts probabilistes, des notions d'électronique, de l'informatique en temps réel. Je pense qu'en fin de master, il est intéressant et gratifiant de mettre en pratique une partie de l'ensemble des connaissances accumulées durant cinq années d'études. L'objectif de mettre en pratique une grande partie de mes connaissances était un souhait dès le début de ce mémoire. J'estime que cet objectif a été atteint. En plus d'avoir revu et mis en pratique des concepts connus, j'ai appris de nouvelles choses dans chacun des domaines abordés. Finalement, ce mémoire a suscité ma curiosité dans chacun des sous-domaines présentés. Bien que ce mémoire soit terminé, je vais continuer à approfondir mes connaissances pour donner des réponses aux nouvelles questions qui se sont ouvertes. En effet, un travail scientifique lève au moins autant de nouvelles questions qu'il essaye d'y répondre.      
\section{Travail de taille importante} 
S'informer, définir les objectifs, faire des recherches de référence, implémenter et rédiger ce mémoire sont autant d'étapes qui ont rythmé cette dernière année de master. Autant d'étapes importantes qui doivent être réparties et incrustées dans l'ensemble des autres cours et activités personnelles. Ce mémoire m'a donc appris énormément de choses sur mes capacités de gestion du stress, sur l'évaluation de mes capacités de travail et sur l'évaluation de la charge de travail. Ces compétences sont primordiales pour mener à bien un projet. Il a donc été important de me remettre constamment en question, de réévaluer régulièrement l'état d'avancement du travail, de jauger si le travail effectué correspond bien aux attentes des directeurs, et au besoin d'adapter les objectifs. Il est possible de les adapter soit en les modifiant soit en les revoyant à la baisse ou au contraire en les revoyant à la hausse. Je pense que bien que cet exercice soit difficile et les débuts laborieux, ce mémoire m'a permis de vraiment m'améliorer sur les différents points abordés. J'ai par exemple appris à diviser chaque partie d'un travail en sous-parties. Ceci permet d'appréhender le travail plus facilement qu'en voulant l'attaquer sur tous les fronts. Cette technique permet également d'évaluer plus facilement son état d'avancement. Il est plus facile de définir l'avancement global lorsqu'un certain nombre de sous-tâches sont terminées plutôt qu'avoir un ensemble des sous-tâches en cours d'avancement.  
